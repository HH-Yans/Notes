<!-- @import "[TOC]" {cmd="toc" depthFrom=2 depthTo=3 orderedList=false} -->

<!-- code_chunk_output -->

- [概念](#概念)
  - [编程范式](#编程范式)
  - [详细说明面向对象三大特性](#详细说明面向对象三大特性)
  - [继承与组合的区别](#继承与组合的区别)
  - [预处理、编译、汇编、链接的区别](#预处理-编译-汇编-链接的区别)
  - [静态编译和动态编译的区别](#静态编译和动态编译的区别)
  - [静态链接和动态链接的区别](#静态链接和动态链接的区别)
  - [静态联编和动态联编的区别](#静态联编和动态联编的区别)
  - [成员初始化列表](#成员初始化列表)
  - [指针与引用的区别](#指针与引用的区别)
  - [右值引用](#右值引用)
  - [浅拷贝与深拷贝的区别](#浅拷贝与深拷贝的区别)
- [关键字](#关键字)
  - [pragma pack(n)](#pragma-packn)
  - [extern](#extern)
  - [inline](#inline)
  - [volatile](#volatile)
  - [const](#const)
  - [static](#static)
  - [define 和 typedef 的区别](#define-和-typedef-的区别)
  - [四种类型转换](#四种类型转换)
- [对象模型](#对象模型)
  - [构造函数/析构函数](#构造函数析构函数)
  - [访问控制](#访问控制)
  - [虚函数/虚表/虚继承](#虚函数虚表虚继承)
- [内存管理](#内存管理)
  - [大小端判断](#大小端判断)
  - [C++ 内存分配情况](#c-内存分配情况)
  - [野指针和悬空指针的区别](#野指针和悬空指针的区别)
  - [new 和 malloc 的区别](#new-和-malloc-的区别)
  - [智能指针](#智能指针)
  - [段错误原因](#段错误原因)
  - [内存泄漏的可能原因](#内存泄漏的可能原因)
  - [RAII](#raii)
- [多线程](#多线程)
  - [std::thread 基本操作](#stdthread-基本操作)
  - [常用的锁](#常用的锁)
  - [std::atomic 的基本操作](#stdatomic-的基本操作)
- [STL](#stl)

<!-- /code_chunk_output -->

---
## 概念
---
### 编程范式
#### OOP（面向对象编程）
**定义：** 将程序中的数据和行为封装在对象中，并通过类（class）来定义对象的蓝图。

**特征：** 封装、继承、多态是OOP的三大特征。
- 封装将数据和行为封装在对象中
- 继承允许一个类继承另一个类的属性和方法
- 多态允许使用不同的对象和方法来处理不同的数据类型。

**优点：**
- 封装性：允许将数据和操作数据的方法封装在一起，提高代码的模块化和可维护性。
- 继承性：支持通过继承机制复用代码，减少重复编写，提高可扩展性。
- 多态性：允许使用统一的接口处理不同类型的对象，提高代码的灵活性。
- 易读性和可维护性：提供了直观的面向对象的模型，使得代码更容易理解、扩展和维护。

**缺点：**
- 性能开销：面向对象的运行时开销可能较大，对象的创建、销毁、动态分派等操作可能对性能产生一定的影响，特别是在性能要求较高的应用中。
- 复杂性：面向对象的设计和实现可能变得复杂，尤其是在处理大型和复杂的系统时。设计良好的对象模型需要花费大量的时间和精力。
- 过度设计风险：为了实现灵活性和可扩展性，程序员可能会过度设计对象模型，导致系统复杂性的增加。这也被称为过度工程。
- 多继承的复杂性：多继承可能导致复杂性的增加，因为它引入了菱形继承等问题，可能导致代码难以理解和调试。
- 耦合度高：在面向对象编程中，类之间的关系可能导致耦合度增加，使得代码难以修改和维护。
- 难以调试：在某些情况下，特别是在多层次继承、多态性等复杂情况下，调试可能会变得更加困难。

**适用场景：**
- 适用于需要将数据和操作数据的方法组织在一起的场景。
- 适用于需要通过继承和多态性实现代码复用和灵活性的场景。
- 适用于对模块化、易读性和可维护性有较高要求的场景。

#### GP（泛型编程）
**定义：** 通过使用泛型（generic）类型和算法，实现在不指定具体数据类型的情况下编写通用的代码。

**特征：** 泛型编程提供了参数化类型的能力，允许在编写代码时使用抽象的数据类型而不是具体的数据类型。（通常会将数据和行为分离，以提高代码的通用性和可复用性）

**优点：**
- 代码重用：允许编写通用的、与数据类型无关的代码，提高代码的重用性。
- 性能优化：生成的代码可以针对特定数据类型进行优化，可以在某些情况下提供更好的性能。
- 灵活性：泛型编程允许更灵活地操作不同类型的数据，适用于需要对多种数据类型进行操作的场景。
- 静态类型检查：在编译时进行类型检查，有助于捕获一些潜在的类型相关的错误。

**缺点：**
- 复杂性：使用泛型编程可以使代码更加通用，但也可能增加代码的复杂性。特别是在使用高级泛型特性时，代码可能变得难以理解和维护。
- 编译时错误信息难以理解：编译时产生的错误信息可能会相对较复杂，难以理解。这使得调试过程可能更加困难。
- 编译时间增加：使用泛型代码可能导致更长的编译时间，因为编译器需要生成多个具体的代码实例。
- 难以调试：泛型代码可能会导致模板的实例化，使得在调试时跟踪代码变得更加困难。在一些编译器中，对于模板代码的调试支持可能不如对非泛型代码的支持。
- 模板元编程复杂性：模板元编程是一种使用编译时计算的技术，它可以使代码在编译时生成。虽然这在某些情况下很强大，但它也可能导致代码的复杂性增加，可读性降低。
- 限制于静态类型系统：泛型编程通常依赖于编译时类型信息，这限制了其在一些动态语言或需要运行时动态类型的情况下的应用。
- 模板代码重复：使用模板时，为了支持不同的数据类型，可能需要编写大量类似的代码，这可能导致模板代码的重复。

**适用场景：**
- 适用于需要编写与具体数据类型无关的通用代码的场景。
- 适用于需要对多种数据类型进行操作的场景。
- 适用于性能要求较高、需要进行类型检查的场景。



### 详细说明面向对象三大特性
**封装：** 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让信任的类或者对象操作，对不可信的进行信息隐藏。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问，通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。

**继承：** 可以让某个类型的对象获得另一个类型的对象的属性的方法。继承可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
继承的两种实现方式：
- 实现继承：直接使用基类的属性和方法而无需额外编码。
- 接口继承：仅使用属性和方法的名称，子类必须提供方法的实现。

**多态：** 向不同的对象发送同一个消息，不同对象在接受时会产生不同的行为。即一个接口，可以实现多种方法。
多态分为静态多态与动态多态：
- 静态多态：通过方法的重载实现，编译时期就能确定方法的调用。
- 动态多态：通过方法的重写和接口实现，发放的具体实现是在运行时确定。



### 继承与组合的区别
**继承：**
- 定义：通过从现有类派生新类，新类继承了原始类的属性和行为。
- 关系：表示"is-a"关系，子类是父类的一种类型。
- 代码重用：提供了代码重用的机制，子类可以使用父类的成员变量和成员函数，同时可以覆盖或扩展这些成员。
- 优点：提高了代码的可扩展性和可维护性，有助于构建层次结构，派生类可以重用基类的代码。
- 缺点：造成了类之间的紧耦合，增加了系统的复杂性，可能导致继承层次过深，难以理解和维护。

**组合：**
- 定义：通过将一个类的对象嵌入到另一个类中，新类通过包含其他类的对象来获得所需的功能。
- 关系：表示"has-a"关系，一个类包含另一个类的对象。
- 代码重用：使用其他类的对象，但不继承其实现，而是通过委托调用其成员函数。
- 优点：降低了耦合度，提高了灵活性，更容易理解和维护。
- 缺点：不能直接使用被组合类的成员变量和成员函数，需要通过组合类的接口进行间接调用。


### 预处理、编译、汇编、链接的区别
**预处理：** 进行一些文本替换和宏展开等操作，预处理器会执行`#`开头的预处理指令，替换宏定义，条件编译，删除注释等。输出一个`.i`文件。

**编译：** 编译器将预处理后的源代码翻译成汇编语言，会进行语法和语义检查，生成相应的目标文件，输出一个`.s`文件。

**汇编：** 汇编器将汇编语言代码翻译成机器语言指令，这些指令打包成可重定位目标程序，即`.o`文件，是二进制文件，它的字节码是机器语言指令，不再是字符。

**链接：** 链接器将多个目标文件和库文件组合成一个可执行文件。解析符号引用，将各个目标文件和库文件组合在一起，解决地址引用关系，生成最终的可执行文件。链接器的输出是一个可以在操作系统上运行的可执行文件。



### 静态编译和动态编译的区别
**静态编译：**
- 特点：在编译阶段将程序源代码转换为机器码，并生成一个独立的可执行文件。
- 生成物：生成的可执行文件包含所有程序所需的代码和数据，形成一个独立的、与编译环境无关的二进制文件。
- 依赖关系：执行时不依赖于外部的库文件，所有的代码和库函数都在可执行文件中。
- 优点：执行时性能相对较好，因为所有的优化都在编译阶段完成，无需在运行时再进行额外的处理。
- 缺点：可执行文件体积较大。

**动态编译：**
- 特点：在运行时将程序源代码转换为机器码。
- 生成物：不生成一个独立的可执行文件，而是在运行时生成和加载机器码。
- 依赖关系：可能依赖于外部的库文件，某些代码在运行时才与库函数进行链接，形成动态链接关系。
- 优点：允许在运行时进行一些优化，使得程序能够适应不同的运行环境，且能够实现一些延迟加载的策略。
- 缺点：会产生一些动态链接的开销。



### 静态链接和动态链接的区别
**静态链接：**
- 特点：在编译阶段将程序的目标文件与库文件合并，生成一个独立的可执行文件。
- 生成物：可执行文件中包含了程序的目标代码以及所依赖的库文件的目标代码，形成一个独立、完整的可执行文件。
- 运行时：执行时不需要外部的库文件，因为所有的库代码都在可执行文件中。
- 文件类型：静态链接生成的可执行文件一般较大。
- 优点：执行时性能相对较好，因为所有的优化和链接都在编译阶段完成。

**动态链接：**
- 特点：在程序运行时，操作系统或运行时链接器将程序的目标文件与库文件动态地链接在一起。
- 生成物：可执行文件只包含程序的目标代码，而依赖的库文件被保留在独立的共享库中。
- 运行时：在执行时，程序会动态加载所需的共享库，形成动态链接关系。如果多个程序都使用相同的库，这些程序可以共享同一份内存中的库代码。
- 文件类型：动态链接生成的可执行文件一般较小。
- 优点：节省系统资源，因为共享库可以被多个程序共享，降低了可执行文件的体积。



### 静态联编和动态联编的区别
**静态联编（早绑定）：**
- 特点：在编译阶段确定函数调用的绑定关系。
- 例子：函数重载和运算符重载。
- 优点：性能相对较好，因为绑定关系在编译时就已确定，无需在运行时进行查找。
- 缺点：缺乏灵活性，不支持运行时的多态性，难以实现一些动态行为。
-
**动态联编（晚绑定）：**
- 特点：在运行时根据对象的实际类型确定函数调用的绑定关系。
- 例子：虚函数。
- 优点：提供了更高的灵活性，支持运行时的多态性，可以在程序运行时适应对象的实际类型。
- 缺点：运行时开销相对较高，因为需要进行动态查找和解析。



### 成员初始化列表
可以少一次调用默认构造函数的过程
**必须使用的场景**
- 常量成员：只能初始化，不能赋值
- 引用类型：必须定义时初始化，不能重新赋值
- 没有默认构造函数的类：初始化列表可以不调用默认构造函数



### 指针与引用的区别
**指针**
- 是一个变量，用于存储另一个变量的地址
- 可以为空，可以不初始化，可以修改指向
- 本身是变量，占用内存空间

**引用**
- 是一个别名，用于绑定另一个变量
- 不可为空，必须初始化，不可重新绑定
- 本身不是独立变量，不占用额外的内存

通常需要判断是否指向为空、指向对象需要变化时用指针，其他情况用引用



### 右值引用
实现移动语义，无需进行深拷贝。
```C++
#include <iostream>

void processValue(int& lvalue) {
    std::cout << "Processing lvalue: " << lvalue << std::endl;
}

void processValue(int&& rvalue) {
    std::cout << "Processing rvalue: " << rvalue << std::endl;
}

int main() {
    int x = 42;
    processValue(x);         // 调用处理左值的函数
    processValue(123);       // 调用处理右值的函数

    int&& rref = 456;        // 右值引用的声明和初始化
    processValue(std::move(rref)); // 调用处理右值的函数，使用std::move()转移资源所有权

    return 0;
}
```



### 浅拷贝与深拷贝的区别
- **浅拷贝：** 仅复制对象的成员变量，而不复制对象所指向的内存，新旧对象会共享同一块内存。如果对象包含指向动态分配内存的指针，浅拷贝后，两个对象的指针指向同一块内存，则可能导致一个对象释放内存后，另一个对象仍然引用这块被释放的内存。
- **深拷贝：** 复制对象的所有内容，包括指向的动态分配内存。新旧对象拥有独立的内存副本。





---
## 关键字
---
### pragma pack(n)
设定结构体、联合、类成员变量以 n 字节对齐
```C++
#pragma pack(push)  // 保存对齐状态
#pragma pack(4)     // 设定为 4 字节对齐

struct test{
    char m1;
    double m4;
    int m3;
};

#pragma pack(pop)   // 恢复对齐状态
```



### extern
- 与变量/函数联用：标识定义在其他文件中
- extern "C"：告诉编译器用 C 的规则翻译函数名（C++为了解决多态的问题，使用“函数名+参数”生成中间函数名

**使用限制：** 定义与声明分开
```C++
// foo.h
int foo;
extern int foo;
/*
  main.c 和 other.c 都包含了 foo.h，
  编译时会得到 main.o 和 other.o，
  且两者都定义了一个 int foo，导致链接错误
*/
```



### inline
**作用：** 以代码膨胀为代价，节省函数调用开销

**使用限制：**
- 只适合简单函数
- 只是对编译器的建议
- 定义在头文件
- 关键字需要跟定义在一起才起作用 *（inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。）*

**类中的inline：**
- 定义在类中的成员函数默认是内联
- 定义在类外的成员函数需要加inline关键字才是内联的。

**inline函数与宏定义的区别：**
- 宏定义发生在预编译阶段，内联在编译阶段
- 内联会进行参数检查，更加安全
- 使用宏定义需要给所有单元加括号

**虚函数可以是内联函数吗？**
虚函数可以是内联函数，但虚函数表现为多态性的时候不能内联。*（内联是在编译期建议编译器内联，而虚函数的多态性在运行期）*



### volatile
**作用：** 告诉 CPU 从内存访问数据，保证volatile变量之间的顺序性，编译器不会进行乱序优化。 *（由于寄存器访问速度 > 内存访问速度，编译器会优化）*

**场景：**
- 中断服务程序中修改供其他程序检测的变量
- 多线程中被多个任务共享的变量
- 并行设备的状态寄存器



### const
**全局变量**
- 作用域限制在其定义时所在的编译单元
- 被修饰的全局变量不允许被修改 *（存放在数据段，修改触发段错误）*
- 用来取代宏定义的好处
  - 编译时能进行类型检查，一旦出错，比宏定义更方便调试
  - 宏定义会进行多处替换，会开辟多处临时内存比较浪费，而const只会开辟一块内存。

**局部变量**
const修饰的局部变量不是真正不变的，可以由指针来修改。

**指针**
- 顶层const：表示这个指针是常量，指向不可改变
- 底层const：表示所指的对象是常量，实际对象不可改变

**函数参数**
const修饰参数是为了防止函数体内可能会修改参数原始对象。
- 值传递：传递一份参数的拷贝，参数不需要声明为const
- 指针：进行浅拷贝，顶层const可以防止指针指向被篡改，底层const可以防止指向对象被篡改
- 引用：不拷贝对象，加上const可以防止修改引用的对象

**函数返回值**
返回一个右值，可以防止调用方修改，提高代码安全性。

**成员变量**
- 成员变量不可被修改
- 只能在初始化列表中初始化

**成员函数**
- 不能修改非`mutable`的成员对象
- 不能调用类中任何非`const`成员函数
- 如果一个成员函数功能上不需要修改对象的内容，该成员函数应该加上`const`修饰。
- const 对象调用 non-const 成员函数时会报错，所以在设计函数时就要考虑该加 const 的一定要加上
- 当成员函数同时存在 const 和 non-const 版本时，const 对象只会调用 const 版本，non-const 对象只会调用 non-const 版本
- operator[] 的 const 版本不需要考虑 COW，non-const 版本共享数据需要考虑 COW

**const 和 constexpr 的作用和区别**
- const 用来修饰变量表示其只读（不代表不可修改）
- constexpr用来表示常量（在编译期就可以计算出结果）



### static
**全局静态变量**
- 存放在静态存储区，生命周期为整个程序运行期间
- 默认初始化为 0
- 作用域在定义处开始到文件结尾

**局部静态变量**
- 存放在静态存储区，生命周期为整个程序运行期间
- 默认初始化为 0
- 作用域为定义处开始到函数或者语句块结束

**静态函数**
- 限制作用域，只能在声明文件可见

**类的静态成员**
- 被整个类共有，不会被对象独有
- 需要在类外进行定义

**类的静态函数**
- 被整个类共有，不会被对象独有
- 只能处理静态数据
- 没有this指针

**static 与 extern 具有冲突的语义**
**static 与 const 对于成员函数具有冲突的语义**



### define 和 typedef 的区别
- define 是宏定义，是预处理指令，作字符串替换，不具有正确性检查的功能
- typedef 是类型定义，有自己的作用域，可以给一个已经存在的类型起别名，具有类型检查的功能



### 四种类型转换
- static_cast：通常用于类层次结构中的相关类型之间的转换，以及常规类型之间的转换。静态转换在编译时执行，不提供运行时检查。
- const_cast：将 const 转为非 const，只对底层 const 有效
```C++
// 常量转换主要用于去除常量性，但在改变常量对象的值时要小心使用，因为这可能导致未定义行为。
const int value = 42;
int& mutableRef = const_cast<int&>(value);
mutableRef = 55;  // 这样的操作是不安全的
```
- dynamic_cast：动态类型转换，在运行时执行，并提供类型安全检查。只用于含有虚函数的类，只能转换指针、引用，向下转非法时，指针返回 null，引用抛出异常
- reinterpreter_cast:什么都能转，这种转换是非常低级和不安全的，慎用。





---
## 对象模型
---
### 构造函数/析构函数
#### 构造函数类型
**默认构造函数：** 如果没有明确定义默认构造函数，编译器会自动生成，函数为空，什么也不做。

**一般构造函数：** 一般构造函数可以有各种参数形式，一个类可以有多个一般构造函数，前提是参数的个数或者类型不同，创建对象时根据传入参数调用不同的构造函数。

**拷贝构造函数：** 函数参数为对象本身的引用，用于根据一个已存在的对象复制出一个新的对象，如果没有显示定义，编译器会默认创建一个，如果类中有指针成员，最好自己定义并进行深拷贝。

调用拷贝构造函数的情况：
- 使用一个对象初始化另一个对象
- 以值传递的方式传递对象给函数
- 从函数返回对象
- 初始化标准容器中的元素 *（某些情况下编译器会优化，使用移动构造或者进行返回值优化）*

**类型转换构造函数：** 根据指定类型的对象创建一个本类的对象，用在不允许默认转换的场合，声明为`explict`来阻止隐式转换的发生。

#### 拷贝构造、拷贝赋值、移动构造、移动赋值
被调用的情况：
- 有类型声明时：调用构造
- 之前定义过，用等号接收的：调用赋值
- 接收的是右值：移动构造/移动赋值
- 接收的是左值：拷贝构造/拷贝赋值

实现方法
```C++
class HasPtr {
  friend void Swap(HasPtr&, HasPtr&);
public:
  // default constructor
  HasPtr(const string& s = string()) : ps_(new string(s)), i_(0) { }

  // copy constructor
  HasPtr(const HasPtr& p) : ps_(new string(*p.ps_)), i_(p.i_) { }

  // copy assignment operator
  HasPtr& operator=(const HasPtr);

  // move constructor
  HasPtr(HasPtr&& p) noexcept : ps_(p.ps_), i_(p.i_) { p.ps_ = nullptr; }

  // move assignment operator
  HasPtr& operator=(HasPtr&&) noexcept;

  // destructor
  ~HasPtr() { delete ps_; }

private:
  string * ps_;
  int i_;
};

// copy assignment operator
HasPtr& operator=(const HasPtr rhs)
{
  Swap(*this, rhs);
  return *this;
}

// move assignment operator
HasPtr& operator=(const HasPtr&& rhs) noexcept
{
  if (this != &rhs) {
    delete ps_;
    ps_ = rhs.ps_;
    i_ = rhs.i_;
    rhs.ps_ = nullptr;
  }
  return *this;
}

inline void Swap(HasPtr& lhs, HasPtr& rhs)
{
  std::swap(lhs.ps_, rhs.ps_);
  std::swap(lhs.i_, rhs.i_);
}
```

#### 为什么拷贝构造函数必须引用传递，不能值传递
避免递归调用导致栈溢出。

#### 构造函数与析构函数的执行顺序
- 构造函数的执行顺序：
  1. 基类构造函数。*（如果有多个基类，则是类派生表中的出现顺序，而不是成员初始化表中的顺序）*
  2. 成员类对象构造函数。*（如果有多个成员类对象，则是在类中被声明的顺序，而不是成员初始化表中的顺序）*
  3. 派生类构造函数。
- 析构函数的执行顺序：
  1. 派生类的析构函数。
  2. 成员类对象的析构函数。
  3. 基类的析构函数。

#### 析构函数能不能抛出异常
不建议。假如析构函数抛出异常，异常点后不能执行，如果在异常点后执行了释放资源之类的操作，则会造成内存泄漏。异常发生时，会调用对象的析构函数来释放资源，即析构是异常处理的一部分。
一个好的设计是在析构函数中使用`noexcept`来表示不会抛出异常。但是即使使用了`noexcept`，如果析构函数调用了其他可能抛出异常的函数，任然需要小心处理异常，以确保不会引发未捕获的异常。






### 访问控制
|               |  public   | protected | private |
| :-----------: | :-------: | :-------: | :-----: |
|  public继承   |  public   | protected | 不可用  |
| protected继承 | protected | protected | 不可用  |
|  private继承  |  private  |  private  | 不可用  |



### 虚函数/虚表/虚继承
#### 虚函数和纯虚函数的作用和区别
- 对于虚函数，子类可以重新定义基类的虚函数，也可以不定义，不定义就会自动调用基类的缺省虚函数实现
- 对于纯虚函数，子类必须提供纯虚函数的个性化实现，否则编译不通过

#### 析构函数一般写成虚函数的原因
降低内存泄漏的可能性。如果有一个基类的指针指向派生类的对象，在使用完要销毁时，如果基类的析构函数没有定义成虚函数，那么根据指针类型会调用基类的析构函数，仅执行基类的析构，派生类的自身内容无法被析构，造成内存泄漏。

#### 构造函数不能定义为虚函数的原因
虚函数的调用是通过实例化后，对象首地址的虚函数表指针来找到虚函数的地址进行调用的，而调用构造函数进行实例化之前是不存在对象的。所以这两者是冲突的。

#### 构造/析构中调用虚函数
在构造函数和析构函数的执行期间，对象的类型会发生变化，而虚函数的调用是动态绑定的，需要在运行时确定正确的函数版本。这会导致一些不直观的结果和潜在问题。
- 构造函数中调用虚函数：
  - 基类构造函数中调用虚函数时，由于派生类对象的构造尚未完成，而虚函数的实现可能依赖派生类的初始化，这可能导致未定义的行为。
  - 构造函数中调用虚函数不会导致动态绑定。基类构造函数总是调用基类版本的虚函数，而不管对象的实际类型。
- 虚构函数中调用虚函数：
  - 派生类的析构函数被调用时，对象的派生类部分可能已经被销毁，因此调用虚函数可能导致未定义的行为。
  - 析构函数中调用虚函数不会导致动态绑定。而是调用析构函数所属的类的版本。

总而言之，需要避免这种设计，防止潜在的问题。

#### 多态机制的实现
动态多态由虚函数和继承关系实现，在运行时确定。
当一个类具有虚函数时，类会维护一个虚表，存储在只读数据段，虚表中存储着虚函数的地址。派生类继承自基类，也会生成自己的虚函数表。当用具有虚函数的类定义一个对象时，会在对象的首地址有一个虚函数表指针，指向该类的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。
在代码中，如果有一个基类的指针指向派生类，那么当调用虚函数时，就会根据对象首地址的虚函数表指针查找虚函数表，在虚函数表中找到对应虚函数的地址后，就可以通过该地址调用该派生类的虚函数，从而实现多态。

#### 虚函数、虚继承内存模型
https://zhuanlan.zhihu.com/p/41309205









---
## 内存管理
---
### 大小端判断
```C++
int main()
{
    int i = 1;
    if (*(char*)(&i) == 1)
        printf("小端模式\n");
    else
        printf("大端模式\n");
    return 0;
}
```



### C++ 内存分配情况
C++ 的内存结构分为：
- 代码段：保存包含执行指令的编译程序的地方
- 常量存储区：存储常量，一般不允许修改
- 静态存储区：维护全局变量和静态变量的地方，在程序编译的时候就分配好，在整个运行周期都存在（全局变量、static变量）
- 栈：由编译器管理分配和回收，存储函数的返回地址、参数、局部变量、返回值
- 堆：由程序员管理，手动进行分配和回收
  1. C 函数：malloc()/free()，不可被重载
  2. C++ 表达式：new/delete，不可被重载
  3. C++ 函数：::operator new()/::operator delete()，可以被重载
  4. C++ 标准库：allocator::allocate()/allocator::deallocate()，可以自行设计并且在容器中使用较多



### 野指针和悬空指针的区别
- 野指针：没有被初始化的指针，用`gcc -Wall`编译会出现`used uninitialized`警告。
- 悬空指针：指向的内存已经被释放的一种指针。

这两种指针都是指向无效内存区域，访问将会导致未定义行为。



### new 和 malloc 的区别
- 属性
  - new/delete 操作符、可重载
  - malloc/free 库函数
- 参数
  - new/delete 按数据类型分配
  - malloc/free 按指定大小分配
- 返回
  - new/delete 对象类型的指针
  - malloc/free void*
- 失败
  - new/delete 抛出 bad_alloc 异常 *（可以用 std::set_new_handler 设定回调函数）*
  - malloc/free 返回 NULL
- 复杂数据类型
  - new/delete 会调用构造/析构函数
  - malloc/free 只能申请/释放内存
- 扩容
  - new/delete 用 placement new
  - malloc/free 用 realloc
- 数组
  - new[] 一次分配内存，多次 ctor
  - malloc 只能 sizeof(type) * n



### 智能指针
shared_ptr、unique_ptr、weak_ptr
- shared_ptr：允许多个指针指向同一个对象
  - 实现原理：
    是一个模板类，封装了被管理对象的指针跟一个控制块指针，控制块包含 shared_ptr 引用计数、weak_ptr 引用计数（用 make_shared 时，可能 shared 计数 0，weak 计数非 0，导致对象内存未及时释放）
  - 引用计数
    1. 构造初始化 1
    2. 拷贝构造 +1
    3. 拷贝赋值 左操作对象 -1，右操作对象 +1
    4. 析构 -1，为 0 时释放
  - 解决的问题：
    1. 忘记释放造成的内存泄露
    2. 多个指针指向同一资源时释放所产生的空悬指针
- weak_ptr： 不会控制资源的生命周期，对对象的弱引用，只提供资源的访问手段（不会修改 shared_ptr 引用计数）
  - 解决的问题：
    1. 用来解决循环引用问题，
    2. 用在资源可使用就使用，不可使用就不用的场景（观察者模式，subject 状态改变需要通知观察者，就需要指向观察者的指针，但 subject 不负责管理观察者）
- unique_ptr：“独占”所指向的对象，对象只能被转移，不能被多个指针同时指向
  - 实现原理：
    拷贝构造、拷贝赋值均声明为 delete，但可以移动构造和移动赋值



### 段错误原因
- 访问一个不存在的地址
- 访问系统保护的地址
- 访问只读内存地址
- 读写一个空指针
- 堆栈溢出
- 数组越界



### 内存泄漏的可能原因
- 未释放动态分配的内存
- 在多级指针或嵌套数据结构中，释放顺序错误
- 异常处理不当，导致异常发生点之前分配的内存无法释放
- 循环引用



### RAII
一种C++编程的设计模式，它强调在对象的构造函数中获取资源，在对象的析构函数中释放这些资源。RAII依赖于对象的生命周期来管理资源，使得资源的获取和释放与对象的生命周期保持一致。通过使用RAII，可以避免手动管理资源的复杂性和可能的错误，提高代码的可靠性和可维护性。

使用场景：
- 内存管理 *（智能指针，如`std::unique_ptr`）*
- 文件操作 *（文件流类，如`std::ifstream`）*
- 互斥锁管理 *（如`std::lock_guard`）*
- 数据库连接
- 资源管理类





---
## 多线程
---
### std::thread 基本操作
**join()：** 用于等待线程的结束。调用`join`后，主线程将等待被调用的线程执行完成。
```C++
std::thread myThread(myFunction, 42);
myThread.join(); // 等待线程执行完毕
```
**detach()：** 用于将线程从主线程分离，使得主线程和子线程可以独立执行。分离后的线程将在执行完成后自动释放资源。
```C++
std::thread myThread(myFunction, 42);
myThread.detach(); // 分离线程
```
**get_id()：** 返回线程的唯一标识符。可以用于区分不同的线程。
```C++
std::thread myThread(myFunction, 42);
std::cout << "Thread ID: " << myThread.get_id() << std::endl;
```
**joinable()：** 用于检查线程是否可以被`join`或`detach`。如果线程可以被`join`，返回`true`；如果线程已经被`detach`，返回`false`。
```C++
std::thread myThread(myFunction, 42);
if (myThread.joinable()) {
    myThread.join();
}
```
**swap()：** 用于交换两个线程的内容。
```C++
std::thread myThread1(myFunction, 42);
std::thread myThread2(myFunction, 24);

myThread1.swap(myThread2);
```



### 常用的锁
mutex type：
- std::mutex：最基础的互斥锁，同时只能有一个持有者
- std::shared_mutex：类似于读写锁，拥有独家访问（写锁）和共同访问（读锁）两种访问方法
- std::recursive_mutex：递归互斥锁，允许同一线程多次锁定同一个锁，避免了死锁的情况
- std::condition_variable：条件变量，用于在多线程之间传递信息，当某个条件满足时，唤醒等待的线程。

lock type：
- unique_lock、lock_guard：既可以封装 mutex，也可以封装 shared_mutex
- shared_lock：只能封装 shared_mutex

使用场景：
- 互斥场景：可以有一个 mutex，每次使用的时候用 unique_lock/lock_guard 来封装 mutex
- 读写场景：可以有一个 shared_mutex，读的时候用 shared_lock 来封装，写的时候用 unique_lock/lock_guard 来封装

unique_lock、lock_guard、scoped_lock 选择：
- 如果要用 conditional variable，选择 unique_lock
- 如果有多个 mutex 要同时 lock，选择 scoped_lock
- 如果只 lock 一个 mutex，选择 lock_guard（也可以保持一致用 scoped_lock）



### std::atomic 的基本操作
**load()：** 用于原子地读取`std::atomic`对象的值。
```C++
std::atomic<int> atomicVariable(42);
int value = atomicVariable.load();
std::cout << "Atomic Variable: " << value << std::endl;
```
**store()：** 用于原子地设置`std::atomic`对象的值。
```C++
std::atomic<int> atomicVariable(0);
atomicVariable.store(42);
std::cout << "Atomic Variable: " << atomicVariable.load() << std::endl;
```
**exchange()：** 用于原子地交换`std::atomic`对象的值，并返回之前的值。
```C++
std::atomic<int> atomicVariable(0);
int previousValue = atomicVariable.exchange(42);
std::cout << "Previous Value: " << previousValue << std::endl;
std::cout << "Current Value: " << atomicVariable.load() << std::endl;
```
**fetch_add()/fetch_seb()：** 用于原子地进行加法和减法操作，并返回操作前的值。
```C++
std::atomic<int> atomicVariable(0);
int result = atomicVariable.fetch_add(5);
std::cout << "Previous Value: " << result << std::endl;
result = atomicVariable.fetch_sub(3);
std::cout << "Current Value: " << atomicVariable.load() << std::endl;
```
**compare_exchang_weak()/compare_exchange_strong()：** 用于原子地比较和交换操作。这两个方法返回一个布尔值，表示操作是否成功。
```C++
std::atomic<int> atomicVariable(0);
int expected = 0;
int desired = 42;
if (atomicVariable.compare_exchange_weak(expected, desired)) {
    std::cout << "Exchange succeeded!" << std::endl;
} else {
    std::cout << "Exchange failed!" << std::endl;
}
```





---
## STL
---